
/*BODEGA*/

CREATE TABLE IF NOT EXISTS bodega.producto
(
    id integer NOT NULL DEFAULT nextval('bodega."Producto_id_seq"'::regclass),
    codigo_producto character(30) COLLATE pg_catalog."default" NOT NULL,
    nombre character(10) COLLATE pg_catalog."default" NOT NULL,
    descrpcion character(250) COLLATE pg_catalog."default" NOT NULL,
    precio money NOT NULL,
    CONSTRAINT "Producto_pkey" PRIMARY KEY (id)
);


create table bodega.consola(
 marca character(72) not null,
 modelo character(72) not null)
 /*hereda de producto*/
 inherits ( bodega.producto );


create table bodega.videojuego(
 genero Character(50) not null,
 ano_lanzamiento date not null,
 plataforma Character(72) not null,
 mecanica Character(72) not null)
 inherits (bodega.producto);

/*ejemplo de un insert para consola*/
INSERT INTO bodega.consola (codigo_producto, nombre, descrpcion, precio,categoria ,marca, modelo) VALUES
('C001', 'PlayStation 5', 'Consola de videojuegos PlayStation 5', '499.99',1,'Sony', 'PlayStation 5');

/*ejemplo de un insert para videojuego*/
INSERT INTO bodega.videojuego (codigo_producto, nombre, descrpcion, precio,categoria ,genero, ano_lanzamiento, plataforma, mecanica) VALUES
('V001', 'The Last of Us Part II', 'Juego de acción y aventura', '59.99',2,'Acción', '2020-06-19', 'PlayStation 4', 'Supervivencia');



CREATE TABLE IF NOT EXISTS bodega.bodega
(
    id integer NOT NULL DEFAULT nextval('bodega."Producto_id_seq"'::regclass),
	id_empleado bigint NOT NULL,
    id_sucursal bigint NOT NULL,
    CONSTRAINT "bodega_pkey" PRIMARY KEY (id),
    CONSTRAINT "fk_sucursal" FOREIGN KEY (id_sucursal) REFERENCES sucursal.sucursal(id_sucursal),
	CONSTRAINT  "fk_empleado" FOREIgn key (id_empleado) REFERENCES administrador.empleado(id_empleado)
   
);


CREATE TABLE IF NOT EXISTS bodega.producto_bodega(
 id_producto_bodega serial Not NULL,
 id_bodega integer NOT NULL,
 id_producto integer NOT NULL,
 cantidad int NOT NULL,
 CONSTRAINT "producto_bodega_pkey" PRIMARY KEY (id_producto_bodega),
 CONSTRAINT "fk_producto" FOREIGN KEY (id_producto) REFERENCES bodega.producto(id),
 CONSTRAINT "fk_bodega" FOREIGN KEY (id_bodega) REFERENCES bodega.bodega(id)
);

/*Administrador*/

CREATE TABLE IF NOT EXISTS administrador.empleado
(
    id_empleado integer NOT NULL DEFAULT nextval('administrador.empleado_id_empleado_seq'::regclass),
    rol char,
	usuario Character(75) UNIQUE NOT NULL ,
	contrasena password NOT NULL,
	id_sucursal bigint NOT NULL,
	nombre Character(75) NOt NULL,
	telefono numeric(8) NOT  NULL,
	correo Character(20) NOT NULL,
	CHECK (correo ~'@'),
	CONSTRAINT empleado_pkey PRIMARY KEY (id_empleado)
)



/*SUCURSAL*/
CREATE TABLE IF NOT EXISTS sucursal.sucursal
(   
    id_sucursal integer NOT NULL DEFAULT nextval('sucursal.sucursal_id_sucursal_seq'::regclass),
    direccion character(150) COLLATE pg_catalog."default" NOT NULL,
    nombre character(72) COLLATE pg_catalog."default" NOT NULL,
    no_sucursal integer NOT NULL,
    CONSTRAINT sucursal_pkey PRIMARY KEY (id_sucursal)
)

/*INVENTARIO*/

CREATE TABLE inventario.estanteria(
	id_estanteria serial NOT NULL,
	id_sucursal integer NOT NULL,
	id_empleado integer NOT NULL,
	CONSTRAINT estateria_pkey PRIMARY KEY (id_estanteria),
	CONSTRAINT "fk_sucursal" FOREIGN KEY (id_sucursal) REFERENCES sucursal.sucursal(id_sucursal),
	CONSTRAINT "fk_empleado" FOREIGN KEY (id_empleado) REFERENCES bodega.bodega(id)
	
);


CREATE TABLE inventario.estanteria_producto(
	id_estanteria_producto serial Not NULL,
	id_estanteria integer NOT NULL,
	id_producto_bodega integer NOT NULL,
	no_pasillo Character(50),
	CONSTRAINT estateria_producto_pkey PRIMARY KEY (id_estanteria_producto),
	CONSTRAINT "fk_estanteria" FOREIGN KEY (id_estanteria) REFERENCES inventario.estanteria(id_estanteria),
	CONSTRAINT "fk_producto_bodega" FOREIGN KEY (id_producto_bodega) REFERENCES bodega.producto_bodega(id_producto_bodega)
);


 /* procedimiento para ingresar un usuario*/
CREATE OR REPLACE PROCEDURE administrador.registrar_empleado(
    rol VARCHAR(10),
    usuario VARCHAR(75),
    contrasena TEXT,
    id_sucursal BIGINT,
    nombre VARCHAR(75),
    telefono NUMERIC(8),
    correo VARCHAR(20),
    no_caja INT
)
LANGUAGE plpgsql
AS $$
BEGIN
    IF no_caja IS NULL THEN
        -- si el numero de caja es nulo se inserta en empleado   
		 INSERT INTO administrador.empleado (rol, usuario, contrasena, id_sucursal, nombre, telefono, correo)
        VALUES (rol, usuario, contrasena, id_sucursal, nombre, telefono, correo);
		
    ELSE
        INSERT INTO administrador.cajero (rol, usuario, contrasena, id_sucursal, nombre, telefono, correo,no_caja)
        VALUES (rol, usuario, contrasena, id_sucursal, nombre, telefono, correo,no_caja);
    END IF;
END;
$$;


/*inserte de un empleado*/
CALL  administrador.registrar_empleado(
'B','LuisBodega1','123456',1,'Gerardo',77668945,'luis@gmail.com',null);


/*inserte de un cajero*/
CALL  administrador.registrar_empleado('C','Cajero1','123456',1,'cajero',77668945,'cajero@gmail.com',1);

/* Funcion  login  */

CREATE OR REPLACE FUNCTION administrador.login(p_correo VARCHAR(256), p_contrasena TEXT)
RETURNS TABLE(id_empleado BIGINT, id_sucursal BIGINT, rol CHAR, dato BIGINT,nombre character(72)) AS $$
DECLARE
    rol_empleado CHAR;
	idEmpleado BIGINT;
BEGIN
    -- Obtener el rol del empleado basado en correo y contraseña
    SELECT e.rol, e.id_empleado INTO rol_empleado, idEmpleado
    FROM administrador.empleado e
    WHERE e.correo = p_correo AND e.contrasena = p_contrasena;

    -- Verificar el rol y retornar datos diferentes según el rol
    IF rol_empleado = 'B' THEN
        RETURN QUERY
         SELECT e.id_empleado, b.id_sucursal, e.rol, b.id_bodega, s.nombre
        FROM bodega.bodega b
        LEFT JOIN administrador.empleado e ON e.id_sucursal = b.id_sucursal
		INNER JOIN sucursal.sucursal s ON s.id_sucursal = b.id_sucursal WHERE e.id_empleado=idEmpleado;

    ELSIF rol_empleado = 'I' THEN
        RETURN QUERY
        SELECT   e.id_empleado, i.id_sucursal, e.rol,  i.id_estanteria, s.nombre 
        FROM inventario.estanteria i
        LEFT JOIN administrador.empleado e ON e.id_sucursal = i.id_sucursal
		INNER JOIN sucursal.sucursal s ON s.id_sucursal = i.id_sucursal WHERE e.id_empleado=idEmpleado;

    ELSIF rol_empleado = 'C' THEN
        RETURN QUERY
        SELECT c.id_empleado, c.id_sucursal, c.rol, c.no_caja, s.nombre
        FROM administrador.cajero c
		INNER  JOIN sucursal.sucursal s ON s.id_sucursal = c.id_sucursal WHERE  c.id_empleado=idEmpleado;

    ELSIF rol_empleado = 'A' THEN
        RETURN QUERY
       	SELECT a.id_empleado, a.id_sucursal, a.rol,NULL::BIGINT, s.nombre
        FROM administrador.empleado a
		INNER JOIN sucursal.sucursal s ON s.id_sucursal = a.id_sucursal  WHERE a.id_empleado=idEmpleado;

    ELSE
        RETURN QUERY
        SELECT NULL::BIGINT AS id_empleado, NULL::BIGINT AS id_sucursal, NULL::BIGINT AS rol, 'Rol desconocido' AS datos ,NULL::VARCHAR(75);
    END IF;
END;
$$ LANGUAGE plpgsql;




 CREATE OR REPLACE PROCEDURE bodega.obtener_producto(p_id_producto BIGINT)
LANGUAGE plpgsql
AS $$
DECLARE
    categoria integer;
	v_result RECORD;
BEGIN 

	SELECT p.categoria INTO categoria
    FROM bodega.producto p
    WHERE p.id_producto = p_id_producto; 

 IF categoria = 1 THEN
        -- Consultar y devolver información de consola
        FOR v_result IN
            SELECT * FROM bodega.consola
            WHERE id_producto = p_id_producto
        LOOP
            RAISE NOTICE 'Consola: %', v_result;
        END LOOP;
    ELSE
        -- Consultar y devolver información de videojuego
        FOR v_result IN
            SELECT * FROM bodega.videojuego
            WHERE id_producto = p_id_producto
        LOOP
            RAISE NOTICE 'Videojuego: %', v_result;
        END LOOP;
    END IF;
END;
$$;

/*funcion para insertar y retornar id */

CREATE OR REPLACE FUNCTION sucursal.inser_sucursal(
    p_direccion varchar(150),
    p_nombre varchar(72),
    p_no_sucursal integer,
    p_codigo varchar(72),
    p_correo varchar(150),
    p_telefono varchar(20), -- Cambiado a varchar para manejar formatos de teléfono
    p_horario_apertura time,
    p_horario_cierre time
)
RETURNS INTEGER AS $$
DECLARE
    id INTEGER;
BEGIN
    INSERT INTO sucursal.sucursal (
        direccion, nombre, no_sucursal, codigo, correo, telefono, horario_apertura, horario_cierre
    )
    VALUES (
        p_direccion, 
        p_nombre,
        p_no_sucursal,
        p_codigo,
        p_correo,
        p_telefono,
        p_horario_apertura,
        p_horario_cierre
    )
    RETURNING id_sucursal INTO id; -- Asegúrate de que el nombre de la columna es correcto
    
    RETURN id;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE PROCEDURE  sucursal.insert_sucursal(
    p_direccion VARCHAR(150),
    p_nombre VARCHAR(72),
    p_no_sucursal INTEGER,
    p_codigo VARCHAR(72),
    p_correo VARCHAR(150),
    p_telefono VARCHAR(20),
    p_horario_apertura TIME,
    p_horario_cierre TIME,
    OUT p_id_sucursal INTEGER  
)
LANGUAGE plpgsql
AS $$
BEGIN

    INSERT INTO sucursal.sucursal (
        direccion, nombre, no_sucursal, codigo, correo, telefono, horario_apertura, horario_cierre
    )
    VALUES (
        p_direccion, 
        p_nombre,
        p_no_sucursal,
        p_codigo,
        p_correo,
        p_telefono,
        p_horario_apertura,
        p_horario_cierre
    )
    RETURNING id_sucursal INTO p_id_sucursal; 
	
	INSERT INTO bodega.bodega(id_empleado, id_sucursal)
	VALUES (null,id_sucursal  );

	INSERT INTO administrador.admin(id_empleado, id_sucursal)
	VALUES (null,id_sucursal  );

	INSERT INTO cajero.caja(id_empleado, id_sucursal)
	VALUES (null,id_sucursal  );

	INSERT INTO inventario.estanteria(id_empleado, id_sucursal)
	VALUES (null,id_sucursal  );
	
END;
$$;

/*metodo para insertar  productos a la bodega*/

CREATE PROCEDURE bodega.inser_producto_bodega(p_id_bodega BIGINT, p_id_producto BIGINT, p_cantidad BIGINT)
LANGUAGE plpgsql
AS $$
DECLARE 
    idProducto BIGINT;
BEGIN 
    -- Selecciona el id_producto
    SELECT id_producto INTO idProducto 
    FROM bodega.producto_bodega 
    WHERE id_bodega = p_id_bodega AND id_producto = p_id_producto;

    IF idProducto IS NULL THEN
        -- Si no existe, inserta el nuevo producto
        INSERT INTO bodega.producto_bodega (id_bodega, id_producto, cantidad)
        VALUES (p_id_bodega, p_id_producto, p_cantidad);
    ELSE
        -- Si existe, actualiza la cantidad
        UPDATE bodega.producto_bodega
        SET cantidad = cantidad + p_cantidad
        WHERE id_bodega = p_id_bodega AND id_producto = p_id_producto;
    END IF;
END $$;

/*mover producto de bodega a inventario*/

CREATE OR REPLACE FUNCTION inventario.comprobarexistencia()
RETURNS TRIGGER AS $$
DECLARE ex INTEGER;
BEGIN
  SELECT cantidad  INTO ex FROM bodega.producto_bodega WHERE id_producto_bodega=NEW.id_producto_bodega;
  IF NEW.cantidad>ex THEN 
    RAISE EXCEPTION 'cantidad insuficiente, actualmente solo hay %',ex;
  END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

/*antes del insert*/
CREATE TRIGGER trigger_comprobar
BEFORE INSERT ON inventario.estanteria_producto
FOR EACH ROW
EXECUTE FUNCTION inventario.comprobarexistencia();


CREATE OR REPLACE FUNCTION inventario.actualizar_bodega()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE bodega.producto_bodega 
  SET cantidad = cantidad - NEW.cantidad
  WHERE id_producto_bodega = NEW.id_producto_bodega;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

/*despues del insert*/
CREATE TRIGGER trigger_actualizar
AFTER INSERT ON inventario.estanteria_producto
FOR EACH ROW
EXECUTE FUNCTION inventario.actualizar_bodega();


/*vista para ver los productos de estanteria */
CREATE OR REPLACE VIEW inventario.productos_estanteria AS
select ep.*, p.* from inventario.estanteria_producto ep
INNER JOIN bodega.producto_bodega pb ON pb.id_producto_bodega= ep.id_producto_bodega
INNER JOIN bodega.producto p ON p.id_producto= pb.id_producto